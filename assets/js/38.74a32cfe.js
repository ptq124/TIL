(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{309:function(t,s,v){"use strict";v.r(s);var _=v(13),a=Object(_.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"soc"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#soc"}},[t._v("#")]),t._v(" SOC")]),t._v(" "),s("h2",{attrs:{id:"soc-관심사-분리"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#soc-관심사-분리"}},[t._v("#")]),t._v(" SOC (관심사 분리)")]),t._v(" "),s("p",[t._v("관심사의 분리(SoC)는 소프트웨어 개발에서 가장 기본적인 원칙 중 하나이며, SOLID 원칙 5개 중 2개(단일 책임 및 인터페이스 분리)가 이 개념에서 직접 파생될 정도로 매우 중요합니다.")]),t._v(" "),s("p",[t._v("원칙은 간단합니다. 프로그램을 하나의 단일 블록으로 작성하지 말고 작은 조각으로 나누어 각각 간단한 개별 작업을 완료할 수 있도록 만드는 것입니다.")]),t._v(" "),s("p",[t._v("관심사의 분리 원칙을 준수하면 코드의 다양한 특성을 개선할 수 있습니다.")]),t._v(" "),s("ul",[s("li",[t._v("더 나은 코드 명료성. 각 모듈이 논리적으로 범위가 지정된 일련의 메소드를 가진 간결하고 명확한 API를 가질 때 프로그램에서 어떤 일이 벌어지는지 이해하는 것이 훨씬 더 쉽습니다.")]),t._v(" "),s("li",[t._v("코드 재사용성 향상(DRY 원리). 코드를 재사용하는 주된 이점은 유지관리 비용 절감입니다. 기능을 확장하거나 버그를 수정해야 할 때마다 한 곳만 수정을하는 것이 훨씬 덜 고통스럽습니다.")]),t._v(" "),s("li",[t._v("더 나은 테스트 가능성. 적절한 범위의 기능과 앱의 나머지 부분으로부터 격리된 독립 모듈을 테스트하는 것이 더 쉽습니다. 모듈이 어떻게 작동하는지 보기 위해 전체 환경을 파악할 필요는 없습니다. 인접한 실제 모듈을 더미 mock 또는 가짜 데이터 소스로 교체하기만 하면 충분합니다. 이렇게 수정한 후 출력하여 모듈을 블랙박스로 테스트하거나 연결된 모듈(BDD)에서 호출되는 메서드를 확인하여 화이트박스로 테스트할 수 있습니다.")]),t._v(" "),s("li",[t._v("프로젝트 개발 및 유지보수 성능이 좋아집니다. 새로운 기능이든 기존 기능이든 모듈 격리는 프로그램의 변경사항으로 영향을 받을 수 있는 영역을 범위를 지정하는 데 도움이 되며, 따라서 개발 속도가 빨라집니다.")]),t._v(" "),s("li",[t._v("여러 엔지니어에 의한 동시 개발이 더 용이합니다. 서로 간섭하지 않도록 하기 위해 어떤 모듈을 진행 중인지 합의하면 됩니다. 모듈의 API 업데이트만이 다른 개발자에게 명시적으로 알리는 플래그가 될 수 있으며, 대부분의 변경사항은 다른 제공자의 즉각적인 주의 없이 추가할 수 있습니다. 우수한 테스트 적용 범위와 결합되면 병렬 개발은 단독으로 작업하는 각 개별 엔지니어의 누적 생산성만큼 효율적이 됩니다(보통 더 느림).")])])])}),[],!1,null,null,null);s.default=a.exports}}]);